{
	"solve": {
		"prefix": "solve",
		"body": [
			"/**",
			" *    author:  kolomigor",
			" *    created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
			"**/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"int main() {",
			"  ios::sync_with_stdio(false);",
			"  cin.tie(nullptr);",
			"  $0",
			"  return 0;",
			"}"
		],
		"description": "solve"
	},
	"fenwick": {
		"prefix": "fenwick",
		"body": [
			"template<typename T>",
			"struct Fenwick {",
			"  int n;",
			"  vector<T> t;",
			"",
			"  Fenwick(int _n) {",
			"    n = _n;",
			"    t.resize(n);",
			"  }",
			"",
			"  void modify(int i, T x) {",
			"    while (i < n) {",
			"      t[i] += x;",
			"      i |= i + 1;",
			"    }",
			"  }",
			"",
			"  T get(int i) {",
			"    T res{};",
			"    while (i >= 0) {",
			"      res += t[i];",
			"      i = (i & (i + 1)) - 1;",
			"    }",
			"    return res;",
			"  }",
			"",
			"  T get(int l, int r) {",
			"    return get(r) - get(l - 1);",
			"  }",
			"};"
		],
		"description": "fenwick"
	},
	"sparse_table": {
		"prefix": "sparse_table",
		"body": [
			"template<typename T, typename F>",
			"struct SparseTable {",
			"  int n;",
			"  F func;",
			"  vector<vector<T>> t;",
			"",
			"  SparseTable(const vector<T>& a, const F& f) : func(f) {",
			"    n = int(a.size());",
			"    int max_log = 32 - __builtin_clz(n);",
			"    t.resize(max_log);",
			"    t[0] = a;",
			"    for (int lg = 1; lg < max_log; ++lg) {",
			"      t[lg].resize(n - (1 << lg) + 1);",
			"      for (int i = 0; i <= n - (1 << lg); ++i) {",
			"        t[lg][i] = func(t[lg - 1][i], t[lg - 1][i + (1 << lg - 1)]);",
			"      }",
			"    }",
			"  }",
			"",
			"  T get(int l, int r) {",
			"    int lg = 31 - __builtin_clz(r - l + 1);",
			"    return func(t[lg][l], t[lg][r - (1 << lg) + 1]);",
			"  }",
			"};"
		],
		"description": "sparse_table"
	},
	"segment_tree": {
		"prefix": "segment_tree",
		"body": [
			"struct SegmentTree {",
			"  struct Node {",
			"    ",
			"",
			"    Node() {",
			"      ",
			"    }",
			"",
			"    Node() {",
			"      ",
			"    }",
			"  };",
			"",
			"  Node unite(const Node& a, const Node& b) {",
			"    Node res;",
			"    ",
			"    return res;    ",
			"  }",
			"",
			"  int n;",
			"  vector<Node> t;",
			"",
			"  SegmentTree(int _n) {",
			"    n = _n;",
			"    t.resize(2 * n);",
			"  }",
			"",
			"  void modify(int i, v) {",
			"    for (t[i += n] = Node(v); i > 0; i >>= 1) {",
			"      t[i >> 1] = unite(t[i], t[i ^ 1]);",
			"    }",
			"  }",
			"",
			"  Node get(int l, int r) {",
			"    Node res;",
			"    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
			"      if (l & 1) {",
			"        res = unite(res, t[l]);",
			"        l += 1;",
			"      }",
			"      if (r & 1) {",
			"        r -= 1;",
			"        res = unite(res, t[r]);",
			"      }",
			"    }",
			"    return res;",
			"  }",
			"};"
		],
		"description": "segment_tree"
	},
	"dsu": {
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"  vector<int> p;",
			"",
			"  DSU(int n) {",
			"    p.resize(n);",
			"    iota(p.begin(), p.end(), 0);",
			"  }",
			"",
			"  int find(int x) {",
			"    return x == p[x] ? x : p[x] = find(p[x]);",
			"  }",
			"",
			"  bool unite(int x, int y) {",
			"    x = find(x);",
			"    y = find(y);",
			"    if (x == y) {",
			"      return false;",
			"    }",
			"    p[x] = y;",
			"    return true;",
			"  }",
			"};"
		],
		"description": "dsu"
	},
	"mint": {
		"prefix": "mint",
		"body": [
			"const int MOD = 1e9 + 7; // 998244353;",
			"",
			"struct Mint {",
			"  int x;",
			"",
			"  Mint() {",
			"    x = 0;",
			"  }",
			"",
			"  Mint(int _x) {",
			"    x = _x;",
			"    while (x >= MOD) {",
			"      x -= MOD;",
			"    }",
			"    while (x < 0) {",
			"      x += MOD;",
			"    }",
			"  }",
			"",
			"  Mint(long long _x) {",
			"    x = (_x % MOD + MOD) % MOD;",
			"  }",
			"",
			"  Mint(size_t _x) {",
			"    x = ((long long)_x % MOD + MOD) % MOD;",
			"  }",
			"",
			"  Mint operator+(const Mint& other) {",
			"    return x + other.x;",
			"  }",
			"",
			"  Mint operator-(const Mint& other) {",
			"    return x - other.x;;",
			"  }",
			"",
			"  Mint operator*(const Mint& other) {",
			"    return 1ll * x * other.x;",
			"  }",
			"",
			"  friend Mint inverse(Mint n);",
			"",
			"  friend Mint power(Mint n, int p);",
			"",
			"  Mint operator/(const Mint& other) {",
			"    return *this * inverse(other);",
			"  }",
			"",
			"  Mint& operator+=(const Mint& other) {",
			"    *this = *this + other;",
			"    return *this;",
			"  }",
			"",
			"  Mint& operator-=(const Mint& other) {",
			"    *this = *this - other;",
			"    return *this;",
			"  }",
			"",
			"  Mint operator*=(const Mint& other) {",
			"    *this = *this * other;",
			"    return *this;",
			"  }",
			"",
			"  Mint operator/=(const Mint& other) {",
			"    *this = *this / other;",
			"    return *this;",
			"  }",
			"",
			"  friend ostream& operator<<(ostream& os, const Mint& mint) {",
			"    os << mint.x;",
			"    return os;",
			"  }",
			"};",
			"",
			"Mint inverse(Mint n) {",
			"  return power(n, MOD - 2);",
			"}",
			"",
			"Mint power(Mint n, int p) {",
			"  Mint ans = 1;",
			"  while (p > 0) {",
			"    if (p & 1) {",
			"      ans *= n;",
			"    }",
			"    p >>= 1;",
			"    n *= n;",
			"  }",
			"  return ans;",
			"}",
			"",
			"vector<Mint> fact(1, 1);",
			"vector<Mint> ifact(1, 1);",
			"",
			"Mint C(int n, int k) {",
			"  if (k < 0 || k > n) {",
			"    return 0;",
			"  }",
			"  while (fact.size() <= n) {",
			"    fact.push_back(fact.back() * fact.size());",
			"    ifact.push_back(inverse(fact.back()));",
			"  }",
			"  return fact[n] * ifact[k] * ifact[n - k];",
			"}"
		],
		"description": "mint"
	}
}