{
	"sparse_table": {
		"prefix": "sparse_table",
		"body": [
			"template<typename T, typename F>",
			"struct SparseTable {",
			"  int n;",
			"  F func;",
			"  vector<vector<T>> t;",
			"",
			"  SparseTable(const vector<T>& a, const F& f) : func(f) {",
			"    n = static_cast<int>(a.size());",
			"    int max_log = 32 - __builtin_clz(n);",
			"    t.resize(max_log);",
			"    t[0] = a;",
			"    for (int lg = 1; lg < max_log; ++lg) {",
			"      t[lg].resize(n - (1 << lg) + 1);",
			"      for (int i = 0; i <= n - (1 << lg); ++i) {",
			"        t[lg][i] = f(t[lg - 1][i], t[lg - 1][i + (1 << (lg - 1))]);",
			"      }",
			"    }",
			"  }",
			"",
			"  T get(int l, int r) {",
			"    assert(0 <= l && l <= r && r < n);",
			"    int lg = 31 - __builtin_clz(r - l + 1);",
			"    return f(t[lg][l], t[lg][r - (1 << lg) + 1]);",
			"  }",
			"};",
			""
		],
		"description": "sparse_table"
	},
	"fenwick": {
		"prefix": "fenwick",
		"body": [
			"template<typename T>",
			"struct Fenwick {",
			"  int n;",
			"  vector<T> t;",
			"",
			"  Fenwick(int _n) : n(_n) {",
			"    t.resize(n);",
			"  }",
			"",
			"  void modify(int i, T x) {",
			"    while (i < n) {",
			"      t[i] += x;",
			"      i |= (i + 1);",
			"    }",
			"  }",
			"",
			"  T get(int i) {",
			"    T res{};",
			"    while (i >= 0) {",
			"      res += t[i];",
			"      i = (i & (i + 1)) - 1;",
			"    }",
			"    return res;",
			"  }",
			"",
			"  T get(int l, int r) {",
			"    assert(0 <= l && l <= r && r < n);",
			"    return get(r) - get(l - 1);",
			"  };",
			"};",
			""
		],
		"description": "fenwick"
	},
	"fast_segment_tree": {
		"prefix": "fast_segment_tree",
		"body": [
			"struct FastSegmentTree {",
			"  struct Node {",
			"",
			"    Node() {",
			"",
			"    }",
			"",
			"    Node(int x) {",
			"",
			"    }",
			"  };",
			"",
			"  Node unite(const Node& a, const Node& b) {",
			"    Node res;",
			"",
			"    return res;",
			"  }",
			"",
			"  int n;",
			"  vector<Node> t;",
			"",
			"  FastSegmentTree(int _n) : n(_n) {",
			"    t.resize(2 * n);",
			"  }",
			"",
			"  void modify(int i, int x) {",
			"    i += n;",
			"    t[i] = Node(x);",
			"    while (i > 1) {",
			"      t[i >> 1] = unite(t[i], t[i ^ 1]);",
			"      i >>= 1;",
			"    }",
			"  }",
			"",
			"  Node get(int l, int r) {",
			"    Node res{};",
			"    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
			"      if (l & 1) {",
			"        res = unite(res, t[l++]);",
			"      }",
			"      if (r & 1) {",
			"        res = unite(res, t[--r]);",
			"      }",
			"    }",
			"    return res;",
			"  }",
			"};",
			""
		],
		"description": "fast_segment_tree"
	},
	"simple_segment_tree": {
		"prefix": "simple_segment_tree",
		"body": [
			"struct SimpleSegmentTree {",
			"  struct Node {",
			"",
			"    Node() {",
			"",
			"    }",
			"",
			"    Node(int x) {",
			"",
			"    }",
			"  };",
			"",
			"  Node unite(const Node& a, const Node& b) {",
			"    Node res;",
			"",
			"    return res;",
			"  }",
			"",
			"  int sz;",
			"  vector<Node> t;",
			"",
			"  SimpleSegmentTree(int n) {",
			"    sz = 1;",
			"    while (sz < n) {",
			"      sz <<= 1;",
			"    }",
			"    t.resize(2 * sz - 1);",
			"  }",
			"",
			"  void build(int x, int lx, int rx, vector<int>& a) {",
			"    if (lx + 1 == rx) {",
			"      if (lx < a.size()) {",
			"        t[x] = Node(a[lx]);",
			"      }",
			"      return;",
			"    }",
			"    int m = (lx + rx) >> 1;",
			"    build(2 * x + 1, lx, m, a);",
			"    build(2 * x + 2, m, rx, a);",
			"    t[x] = unite(t[2 * x + 1], t[2 * x + 2]);",
			"  }",
			"",
			"  void build(vector<int>& a) {",
			"    build(0, 0, sz, a);",
			"  }",
			"",
			"  void modify(int i, int v, int x, int lx, int rx) {",
			"    if (lx + 1 == rx) {",
			"      t[x] = Node(v);",
			"      return;",
			"    }",
			"    int m = (lx + rx) >> 1;",
			"    if (i < m) {",
			"      modify(i, v, 2 * x + 1, lx, m);",
			"    } else {",
			"      modify(i, v, 2 * x + 2, m, rx);",
			"    }",
			"    t[x] = unite(t[2 * x + 1], t[2 * x + 2]);",
			"  }",
			"",
			"  void modify(int i, int v) {",
			"    modify(i, v, 0, 0, sz);",
			"  }",
			"",
			"  Node get(int l, int r, int x, int lx, int rx) {",
			"    if (r <= lx || rx <= l) {",
			"      return Node();",
			"    }",
			"    if (l <= lx && rx <= r) {",
			"      return t[x];",
			"    }",
			"    int m = (lx + rx) >> 1;",
			"    Node L = get(l, r, 2 * x + 1, lx, m);",
			"    Node R = get(l, r, 2 * x + 2, m, rx);",
			"    return unite(L, R);",
			"  }",
			"",
			"  Node get(int l, int r) {",
			"    return get(l, r, 0, 0, sz);",
			"  }",
			"};",
			""
		],
		"description": "simple_segment_tree"
	},
	"lazy_segment_tree": {
		"prefix": "lazy_segment_tree",
		"body": [
			"struct LazySegmentTree {",
			"  struct Node {",
			"",
			"    Node() {",
			"",
			"    }",
			"",
			"    Node(int x) {",
			"",
			"    }",
			"  };",
			"",
			"  Node unite(const Node& a, const Node& b) {",
			"    Node res;",
			"",
			"    return res;",
			"  }",
			"",
			"  int sz;",
			"  vector<Node> t;",
			"",
			"  LazySegmentTree(int n) {",
			"    sz = 1;",
			"    while (sz < n) {",
			"      sz <<= 1;",
			"    }",
			"    t.resize(2 * sz - 1);",
			"  }",
			"",
			"  void build(int x, int lx, int rx, vector<int>& a) {",
			"    if (lx + 1 == rx) {",
			"      if (lx < a.size()) {",
			"        t[x] = Node(a[lx]);",
			"      }",
			"      return;",
			"    }",
			"    int m = (lx + rx) >> 1;",
			"    build(2 * x + 1, lx, m, a);",
			"    build(2 * x + 2, m, rx, a);",
			"    t[x] = unite(t[2 * x + 1], t[2 * x + 2]);",
			"  }",
			"",
			"  void build(vector<int>& a) {",
			"    build(0, 0, sz, a);",
			"  }",
			"",
			"  void push(int x, int lx, int rx) {",
			"",
			"  }",
			"",
			"  void modify(int l, int r, int v, int x, int lx, int rx) {",
			"    push(x, lx, rx);",
			"    if (r <= lx || rx <= l) {",
			"      return;",
			"    }",
			"    if (l <= lx && rx <= r) {",
			"",
			"      push(x, lx, rx);",
			"      return;",
			"    }",
			"    int m = (lx + rx) >> 1;",
			"    modify(l, r, v, 2 * x + 1, lx, m);",
			"    modify(l, r, v, 2 * x + 2, m, rx);",
			"    t[x] = unite(t[2 * x + 1], t[2 * x + 2]);",
			"  }",
			"",
			"  void modify(int l, int r, int v) {",
			"    modify(l, r, v, 0, 0, sz);",
			"  }",
			"",
			"  Node get(int l, int r, int x, int lx, int rx) {",
			"    push(x, lx, rx);",
			"    if (r <= lx || rx <= l) {",
			"      return Node();",
			"    }",
			"    if (l <= lx && rx <= r) {",
			"      return t[x];",
			"    }",
			"    int m = (lx + rx) >> 1;",
			"    Node L = get(l, r, 2 * x + 1, lx, m);",
			"    Node R = get(l, r, 2 * x + 2, m, rx);",
			"    return unite(L, R);",
			"  }",
			"",
			"  Node get(int l, int r) {",
			"    return get(l, r, 0, 0, sz);",
			"  }",
			"};",
			""
		],
		"description": "lazy_segment_tree"
	},
	"dsu": {
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"  vector<int> p;",
			"  vector<int> s;",
			"",
			"  DSU(int n) {",
			"    p.resize(n);",
			"    s.resize(n);",
			"    for (int i = 0; i < n; ++i) {",
			"      p[i] = i;",
			"      s[i] = 1;",
			"    }",
			"  }",
			"",
			"  int find(int x) {",
			"    if (x == p[x]) {",
			"      return x;",
			"    }",
			"    return p[x] = find(p[x]);",
			"  }",
			"",
			"  bool unite(int x, int y) {",
			"    x = find(x);",
			"    y = find(y);",
			"    if (x == y) {",
			"      return false;",
			"    }",
			"    if (s[x] > s[y]) {",
			"      swap(x, y);",
			"    }",
			"    s[y] += s[x];",
			"    p[x] = y;",
			"    return true;",
			"  }",
			"};",
			""
		],
		"description": "dsu"
	},
	"tree": {
		"prefix": "tree",
		"body": [
			"struct Tree {",
			"  int n;",
			"  int max_log;",
			"  vector<vector<int>> g;",
			"  vector<int> dep;",
			"  vector<int> par;",
			"  vector<vector<int>> jmp;",
			"",
			"  void dfs(int v, int pr) {",
			"    for (int u : g[v]) {",
			"      if (u == pr) {",
			"        continue;",
			"      }",
			"      par[u] = v;",
			"      dep[u] = dep[v] + 1;",
			"      dfs(u, v);",
			"    }",
			"  }",
			"",
			"  void do_dfs_from(int v) {",
			"    dep[v] = 0;",
			"    par[v] = v;",
			"    dfs(v, v);",
			"  }",
			"",
			"  Tree(int _n, bool parents=false) : n(_n) {",
			"    g.resize(n);",
			"    dep.resize(n);",
			"    par.resize(n);",
			"    if (parents) {",
			"      for (int v = 1; v < n; ++v) {",
			"        int pr;",
			"        cin >> pr;",
			"        --pr;",
			"        g[pr].push_back(v);",
			"        g[v].push_back(pr);",
			"      } ",
			"    }",
			"    for (int i = 0; i < n - 1; ++i) {",
			"      int x, y;",
			"      cin >> x >> y;",
			"      --x; --y;",
			"      g[x].push_back(y);",
			"      g[y].push_back(x);",
			"    }",
			"    do_dfs_from(0);",
			"  }",
			"",
			"  void initLCA() {",
			"    max_log = 32 - __builtin_clz(n);",
			"    jmp.resize(max_log, vector<int>(n));",
			"    jmp[0] = par;",
			"    for (int lg = 1; lg < max_log; ++lg) {",
			"      for (int v = 0; v < n; ++v) {",
			"        jmp[lg][v] = jmp[lg - 1][jmp[lg - 1][v]];",
			"      }",
			"    }",
			"  }",
			"",
			"  int lca(int x, int y) {",
			"    if (dep[x] < dep[y]) {",
			"      swap(x, y);",
			"    }",
			"    for (int lg = max_log - 1; lg >= 0; --lg) {",
			"      if (dep[x] - (1 << lg) >= dep[y]) {",
			"        x = jmp[lg][x];",
			"      }",
			"    }",
			"    if (x == y) {",
			"      return x;",
			"    } ",
			"    for (int lg = max_log - 1; lg >= 0; --lg) {",
			"      if (jmp[lg][x] != jmp[lg][y]) {",
			"        x = jmp[lg][x];",
			"        y = jmp[lg][y];",
			"      }",
			"    }",
			"    return par[x];",
			"  }",
			"};",
			""
		],
		"description": "tree"
	},
	"mint": {
		"prefix": "mint",
		"body": [
			"const int MOD = 998244353;",
			"",
			"struct Mint {",
			"  int x;",
			"",
			"  Mint(): x(0) {}",
			"",
			"  Mint(int64_t _x) {",
			"    _x %= MOD;",
			"    if (_x < 0) _x += MOD;",
			"    x = _x;",
			"  }",
			"",
			"  Mint& operator+=(const Mint& a) {",
			"    x += a.x;",
			"    if (x >= MOD) x -= MOD;",
			"    return *this;",
			"  }",
			"",
			"  Mint& operator-=(const Mint& a) {",
			"    x += MOD - a.x;",
			"    if (x >= MOD) x -= MOD;",
			"    return *this;",
			"  }",
			"",
			"  Mint& operator*=(const Mint& a) {",
			"    x = 1ll * x * a.x % MOD;",
			"    return *this;",
			"  }",
			"",
			"  Mint pow(int64_t pw) const {",
			"    Mint res = 1;",
			"    Mint cur = *this;",
			"    while (pw) {",
			"      if (pw & 1) res *= cur;",
			"      cur *= cur;",
			"      pw >>= 1;",
			"    }",
			"    return res;",
			"  }",
			"",
			"  Mint inv() const {",
			"    return pow(MOD - 2);",
			"  }",
			"",
			"  Mint& operator/=(const Mint& a) {",
			"    return *this *= a.inv();",
			"  }",
			"",
			"  Mint operator+(const Mint& a) const {",
			"    return Mint(*this) += a;",
			"  }",
			"",
			"  Mint operator-(const Mint& a) const {",
			"    return Mint(*this) -= a;",
			"  }",
			"",
			"  Mint operator*(const Mint& a) const {",
			"    return Mint(*this) *= a;",
			"  }",
			"",
			"  Mint operator/(const Mint& a) const {",
			"    return Mint(*this) /= a;",
			"  }",
			"",
			"  bool operator==(const Mint& a) const {",
			"    return x == a.x;",
			"  }",
			"",
			"  bool operator!=(const Mint& a) const {",
			"    return x != a.x;",
			"  }",
			"",
			"  bool operator<(const Mint& a) const {",
			"    return x < a.x;",
			"  }",
			"",
			"  bool operator>(const Mint& a) const {",
			"    return x > a.x;",
			"  }",
			"",
			"  friend ostream& operator<<(ostream&, const Mint& a) {",
			"    cout << a.x;",
			"    return cout;",
			"  }",
			"};",
			"",
			"vector<Mint> fact(1, 1);",
			"vector<Mint> ifact(1, 1);",
			"",
			"Mint C(int n, int k) {",
			"  if (k < 0 || k > n) {",
			"    return 0;",
			"  }",
			"  while (fact.size() <= n) {",
			"    fact.push_back(fact.back() * fact.size());",
			"    ifact.push_back(fact.back().inv());",
			"  }",
			"  return fact[n] * ifact[k] * ifact[n - k];",
			"}"
		],
		"description": "mint"
	},
	"multitest": {
		"prefix": "multitest",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"",
			"void solve() {",
			"  $0",
			"}",
			"",
			"int main() {",
			"  ios::sync_with_stdio(false);",
			"  cin.tie(nullptr);",
			"  int tt = 1;",
			"  cin >> tt;",
			"  while (tt--) {",
			"    solve();",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "multitest"
	},
	"singletest": {
		"prefix": "singletest",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"",
			"void solve() {",
			"  $0",
			"}",
			"",
			"int main() {",
			"  ios::sync_with_stdio(false);",
			"  cin.tie(nullptr);",
			"  int tt = 1;",
			"  //cin >> tt;",
			"  while (tt--) {",
			"    solve();",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "singletest"
	},
	"debug": {
		"prefix": "debug",
		"body": [
			"#define LOCAL",
			"#ifdef LOCAL",
			"#include \"debug.h\"",
			"#else",
			"#define debug(...) 42",
			"#endif"
		],
		"description": "debug"
	},
	"simple": {
		"prefix": "simple",
		"body": [
			"/**",
			" *    author:  kolomig0r",
			" *    created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
			"**/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"int main() {",
			"  ios::sync_with_stdio(false);",
			"  cin.tie(nullptr);",
			"  $0",
			"  return 0;",
			"}"
		],
		"description": "simple"
	}
}